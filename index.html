<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://745162202.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://745162202.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-thinkphp多次load引出foreach的奇怪现象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/11/thinkphp多次load引出foreach的奇怪现象/" class="article-date">
  <time datetime="2020-01-11T15:51:48.000Z" itemprop="datePublished">2020-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/11/thinkphp多次load引出foreach的奇怪现象/">thinkphp 多次 load 引出 foreach 的奇怪现象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近开发中使用多个延迟预载入中遇到了数组被 foreache 循环后，current 获取不到信息，以前也有类似的事情。发现自己对 foreach 的理解很片面，<br>借助这次机会搞懂这个 foreache 循环。</p>
<h2 id="以前遇到过的问题"><a href="#以前遇到过的问题" class="headerlink" title="以前遇到过的问题"></a>以前遇到过的问题</h2><p>foreache 循环引用的变量，在最后一次循环中 数据最后一个有问题。 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	$arr = [1,2,3];</span><br><span class="line"></span><br><span class="line">	foreach ($arr as $k =&gt; &amp;$v) &#123;</span><br><span class="line">		echo $v;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	foreach($arr as $k =&gt; $v) &#123;</span><br><span class="line">		echo $v;</span><br><span class="line">	&#125;</span><br><span class="line">执行结构会是 123122</span><br></pre></td></tr></table></figure>

<p>因为第一次循环的最后一个 $v 引用了 $arr[2],而后面的循环只是循环修改 $v 也就是 $arr[2]。<br>解决方案 unset($v)或者第二个循环换一个变量名称。</p>
<h2 id="本次遇到-foreache-循环问题"><a href="#本次遇到-foreache-循环问题" class="headerlink" title="本次遇到 foreache 循环问题"></a>本次遇到 foreache 循环问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 延迟预载入关联查询</span><br><span class="line"> * @access public</span><br><span class="line"> * @param mixed $relation 关联</span><br><span class="line"> * @return $this</span><br><span class="line"> */</span><br><span class="line">public function load($relation)</span><br><span class="line">&#123;</span><br><span class="line">    if (!$this-&gt;isEmpty()) &#123;</span><br><span class="line">        $item = current($this-&gt;items);</span><br><span class="line">        $item-&gt;eagerlyResultSet($this-&gt;items, $relation);</span><br><span class="line">    &#125;</span><br><span class="line">    return $this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eagerlyResultSet 对 $this-&gt;items 进行 foreache 循环，那么 load 方法被调用第二次 $item = current($this-&gt;items); 就会返回 false。</p>
<p>简化我们的例子：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	$arr = [1,2,3];</span><br><span class="line"></span><br><span class="line">foreach ($arr as $k =&gt; $v) &#123;</span><br><span class="line">	echo $v;</span><br><span class="line">&#125;</span><br><span class="line"> var_dump(current($arr)); //返回 false</span><br></pre></td></tr></table></figure></p>
<p>foreach 读取数据后，指针指向下一个，循环完成后指针就在$a[2]后面一位了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$arr = [1,2,3];</span><br><span class="line"></span><br><span class="line">foreach ($arr as $k =&gt; $v) &#123;</span><br><span class="line">	echo $v;</span><br><span class="line">&#125;</span><br><span class="line">$arr[3]=4;</span><br><span class="line">var_dump(current($arr)); //返回 4</span><br></pre></td></tr></table></figure>

<p>所以循环后需要使用 reset 重置数组的内部指针。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://745162202.github.io/2020/01/11/thinkphp多次load引出foreach的奇怪现象/" data-id="ck59t0zsa0006g0mebc144b84" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mvc的隔离性和一致性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/15/mvc的隔离性和一致性/" class="article-date">
  <time datetime="2019-12-15T11:07:09.000Z" itemprop="datePublished">2019-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/15/mvc的隔离性和一致性/">mvc的隔离性和一致性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>数据库隔离级别 ACID（原子性，一致性，隔离性，持久性）</strong></p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><ul>
<li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<h4 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h4><p>mysql 默认事务隔离级别「可重复读」，在开启事务会有不同的read-view，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。MVCC 可以解决帮助 REPEATABLE-READ（可重复读）的幻读问题，因为他在开启事务的时候就生成视图（readView）</p>
<h3 id="一致性-ReadView"><a href="#一致性-ReadView" class="headerlink" title="一致性,ReadView"></a>一致性,ReadView</h3><p>在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：</p>
<ul>
<li>trx_id这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。</li>
<li>roll_pointer每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日- 志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。</li>
</ul>
<p>readview 在 undo 日志中，readview 结构：</p>
<table>
<thead>
<tr>
<th>结构</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>m_ids</td>
<td>存放当前系统中活跃的事务集合</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>m_ids中最小的事务ID</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>分配给下一个开启事务的事务ID</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>创建此ReadView的事务ID</td>
</tr>
</tbody></table>
<blockquote>
<p>事务ID:只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p>
</blockquote>
<p><img src="/images/mvc-readview.jpg" alt="来源https://www.cnblogs.com/luozhiyun/p/11216287.html"></p>
<ul>
<li>判断trx_id 与 creator_trx_id是否相等，是则意味着此版本正在被当前事务操作，可以访问</li>
<li>判断trx_id是否小于min_trx_id，表示此版本的生成事务已经提交，可以访问</li>
<li>判断trx_id是否大于等于max_trx_id，表示此版本的生成事务已经提交，可以访问</li>
<li>判断trx_id是否在m_ids中，若不在，则意味着此版本的创建事务已经提交，可以访问；若在，则表明此版本在创建ReadView时还在活动，不能访问。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://745162202.github.io/2019/12/15/mvc的隔离性和一致性/" data-id="ck59t0zs40003g0me40lxjs8q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-框架的事务嵌套" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/06/框架的事务嵌套/" class="article-date">
  <time datetime="2019-12-05T16:05:48.000Z" itemprop="datePublished">2019-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/06/框架的事务嵌套/">框架的事务嵌套</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://745162202.github.io/2019/12/06/框架的事务嵌套/" data-id="ck59t0zsf0008g0mewx4z3n47" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-InnoDB索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/04/InnoDB索引/" class="article-date">
  <time datetime="2019-12-04T09:30:19.000Z" itemprop="datePublished">2019-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/04/InnoDB索引/">InnoDB索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>mysql 的数据都是存储在页（16kb）中的，索引也是在页中使用哈希数组链接，指向内容是以链表方式链接的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://745162202.github.io/2019/12/04/InnoDB索引/" data-id="ck59t0zry0001g0mep7zder0u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-InnoDB页" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/23/InnoDB页/" class="article-date">
  <time datetime="2019-11-22T16:25:06.000Z" itemprop="datePublished">2019-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/23/InnoDB页/">InnoDB页</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数据页和数据页之间是双向列表链接。每个页中有 page Directory 有一个个槽（slot） 用来二分快速查找数据。  </p>
<p>如：<br>假设10个槽 将第四个槽拿出来比较，大了就去5-9槽中继续二分，小了就去0-4中继续二分。<br>找到对应的槽后通过单链表一个一个比较，每个槽后面最多八条记录</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>文件头部</td>
<td>38字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>页面头部</td>
<td>56字节</td>
<td>数据页专有的一些信息</td>
</tr>
<tr>
<td>Infimum + Supremum</td>
<td>最小记录和最大记录</td>
<td>26字节</td>
<td>两个虚拟的行记录</td>
</tr>
<tr>
<td>User Records</td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>页面目录</td>
<td>不确定</td>
<td>页中的某些记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>文件尾部</td>
<td>8字节</td>
<td>校验页是否完整</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://745162202.github.io/2019/11/23/InnoDB页/" data-id="ck59t0zs20002g0me47h7zshv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-InnoDB 行格式 " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/22/InnoDB 行格式 /" class="article-date">
  <time datetime="2019-11-22T15:18:17.000Z" itemprop="datePublished">2019-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/22/InnoDB 行格式 /">InnoDB 行格式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="InnoDB-读取数据的方式"><a href="#InnoDB-读取数据的方式" class="headerlink" title="InnoDB 读取数据的方式"></a>InnoDB 读取数据的方式</h3><p>将数据划分为若干页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般是16KB，当需要从磁盘中读取数据时每一次最少将从磁盘中读取16KB的内容到内存中，每一次最少也会把内存中的16KB内容写到磁盘中。</p>
<h3 id="行的分类"><a href="#行的分类" class="headerlink" title="行的分类"></a>行的分类</h3><ol>
<li>Compact:MySQL 5.0时被引入的，其设计目标是能高效存放数据</li>
<li>Redundant:MySQL 5.0版本之前InnoDB的行记录存储方式</li>
<li>Dynamic:类似于Compact行格式，只不过在处理行溢出数据时有点分歧</li>
<li>Compressed:比 Dynamic 多了一个 zlib 算法压缩。对 BLOB、TEXT、VARCHAR 这类大长度类型的数据能进行非常有效的存储<blockquote>
<p>支持的 Compact 和 Redundant 格式将其称为 Antelope 文件格式，Barracuda 文件格式下拥有两种新的行记录格式 Compressed 和 Dynamic 两种。</p>
</blockquote>
<h3 id="行的结构"><a href="#行的结构" class="headerlink" title="行的结构"></a>行的结构</h3></li>
</ol>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>变长字段长度</td>
<td>使用两个字节存储。列加起来最多 65535 个字节（除了blobs和text 类型的列之外，其他所有列(不包含隐藏列和头部信息)）</td>
</tr>
<tr>
<td>Null标志位</td>
<td>一位一个二进制位，1 就标示这一列 null</td>
</tr>
<tr>
<td>记录头信息</td>
<td>见下表</td>
</tr>
<tr>
<td>列数据</td>
<td>真实数据，还有几个隐藏列。唯一标识 row_id (6 字节)，事务ID transaction_id (6字节)，回滚指针 roll_pointer (7 字节)。</td>
</tr>
</tbody></table>
<blockquote>
<p>列数据中的唯一标识只有在没有主键的且没有唯一索引的时候才会添加。  </p>
</blockquote>
<p><strong>记录头信息</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody></table>
<blockquote>
<p>通过 next_record 可以看出行记录时单链表</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://745162202.github.io/2019/11/22/InnoDB 行格式 /" data-id="ck59t0zrp0000g0mekqd3v0r3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/07/mysql-索引/" class="article-date">
  <time datetime="2019-10-07T12:26:41.000Z" itemprop="datePublished">2019-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/07/mysql-索引/">mysql_索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对 mysql索引和 数据页结构，进行研究整理。数据页结构对理解很多索引优化原理很有帮助！下次写一篇关于对数据页结构的文章加深对数据页结构的知识点。</p>
<h2 id="select-type查询类型。"><a href="#select-type查询类型。" class="headerlink" title="select_type查询类型。"></a>select_type查询类型。</h2><table>
<thead>
<tr>
<th>查询类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单查询（不包含子查询或UNION)</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>最外层查询</td>
</tr>
<tr>
<td>UNION</td>
<td>UNION 语句中第二或更后面的查询</td>
</tr>
<tr>
<td>DEPENDENT UNION</td>
<td>依赖外部查询的UNION中第二或更后面的查询</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>UNION语句的结果集</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>子查询中的第一个查询</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>依赖外部查询的子查询中的第一个查询</td>
</tr>
<tr>
<td>DERIVED</td>
<td>查询的派生表(在FROM从句中的子查询）</td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>物化子查询</td>
</tr>
<tr>
<td>UNCACHEABLE SUBQUERY</td>
<td>无法缓存结果的子查询，并且必须为外部查询的每一行重新计算</td>
</tr>
<tr>
<td>UNCACHEABLE UNION</td>
<td>属于无法缓存的子查询的UNION的第二或更后面的查询</td>
</tr>
</tbody></table>
<h2 id="type-级别详解"><a href="#type-级别详解" class="headerlink" title="type 级别详解"></a>type 级别详解</h2><blockquote>
<p>type索引类型<br> system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all，要对 type 进行优化的前提：有索引<br>其中：system,const 只是理想情况；实际能达到 ref&gt;range<br>。<strong>隐式转换会导致索引失效！</strong></p>
<ul>
<li>ALL：MySQL 将遍历全表以找到匹配的行</li>
<li>index: index 与 ALL 区别为 index 类型只遍历索引树</li>
<li>range:只检索给定范围的行，使用一个索引来选择行,常见于使用 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN()或者like等运算符的查询中。<strong>当范围数据量过大会自动变成 All 或 index</strong></li>
<li>ref: <strong>非唯一性索引</strong>，对于每个索引键的查询，返回匹配的所有行（0~多个）</li>
<li>eq_ref: 类似 ref，区别就在使用的索引是唯一索引<strong>且必须为not null</strong>，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用 primary key 或者 unique key 作为关联条件</li>
<li>const、system: 使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描。，system 是 const 类型的特例，当查询的表只有一行的情况下，使用 system</li>
<li>NULL: </li>
</ul>
</blockquote>
<h2 id="Extra字段"><a href="#Extra字段" class="headerlink" title="Extra字段"></a>Extra字段</h2><ul>
<li>Using index ：表示相应的 select 操作中使用了覆盖索引（Covering Index）</li>
<li>Using where; Using index ： 索引来检索记录（不需要实际访问表），在此结果集之上通过 where 过滤。</li>
<li>Using index condition ： 条件包含索引和未索引的列，优化器将首先解析索引的列，通过索引获取数据行再查找其他条件的行(5.6后出现)</li>
<li>Using where ： 表示 mysql 服务器将在存储引擎检索行后再进行过滤</li>
<li>usingFilesort：性能消耗大；需要「额外」的一次排序（查询） 。常见于 order by 语句中。</li>
<li>Using join buffer：标示 Mysql 引擎使用了 连接缓存。</li>
<li>NULL: </li>
</ul>
<h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><ul>
<li>最好全值匹配</li>
<li>最左前缀法则</li>
<li>不在索引列上做任何操作「计算，函数，类型转换（显示、隐式）」</li>
<li>复合索引不能使用 !=、is null (is not null)、in、&gt;、&lt; 否则右侧所有全部失效，有时  也会导致索引失效。</li>
<li>like尽量以“常量”开头，不要以’%’开头，否则索引失效</li>
<li>尽量不要使用or，否则包括左侧的所有索引都会失效</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://745162202.github.io/2019/10/07/mysql-索引/" data-id="ck59t0zs60004g0me5nehl525" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql数据库规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/21/mysql数据库规范/" class="article-date">
  <time datetime="2019-09-21T14:25:06.000Z" itemprop="datePublished">2019-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/21/mysql数据库规范/">mysql数据库规范</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在工作中为开发进度忽略一些建表的规范和索引的建立（基本只有主键索引），写下这个约定也是为了约束自己在开发中潜移默化使用有效的索引和规则的数据表。「参考阿里开发手册加自己的一些经验」。</p>
<h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><p><strong>1.建表规约</strong></p>
<ul>
<li>任何字段如果为非负数，必须是 unsigned。</li>
<li>表名、字段名必须使用小写字母，数据库字段名的修改代价很大，所以字段名称需要慎重考虑。</li>
<li>主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</li>
<li>小数类型为 decimal</li>
<li>定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 （血的教训）</li>
<li>字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： <ul>
<li>不是频繁修改的字段。 </li>
<li>不是 varchar 超长字段，更不能是 text 字段。 <blockquote>
<p>如：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</p>
</blockquote>
</li>
<li>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</li>
</ul>
<strong>2.索引规约</strong></li>
<li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<blockquote>
<p>不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生</p>
</blockquote>
</li>
<li>页面搜索严禁左模糊或者全模糊<blockquote>
<p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
</blockquote>
</li>
<li>如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。</li>
<li>利用覆盖索引来进行查询操作，避免回表。<blockquote>
<p>如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。</p>
</blockquote>
</li>
<li>利用延迟关联或者子查询优化超多分页场景。 <blockquote>
<p>MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。<br>如：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p>
</blockquote>
</li>
<li>SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。 <ul>
<li>consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据</li>
<li>ref 指的是使用普通的索引（normal index）。</li>
<li>range 对索引进行范围检索。</li>
<li>建组合索引的时候，区分度最高的在最左边。使用 <strong>in、&gt;=、《=、&gt;、&lt;、!=、is null、(is not null)</strong> 会导致右边组合索引失效</li>
</ul>
</li>
<li>防止因字段类型不同造成的隐式转换，导致索引失效。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://745162202.github.io/2019/09/21/mysql数据库规范/" data-id="ck59t0zs80005g0menm9i97mo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-增加代码可读性的命名规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/14/增加代码可读性的命名规范/" class="article-date">
  <time datetime="2019-09-14T03:04:02.000Z" itemprop="datePublished">2019-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/14/增加代码可读性的命名规范/">增加代码可读性的命名规范</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>每天开发赶工不注意方法命名的统一，使代码的可读可理解变得很差。本文参考网上文章结合自身的编码习惯做整理。<br><strong>写程序读的代码简单，写人读的代码难</strong></p>
<h2 id="方法函数命名原则"><a href="#方法函数命名原则" class="headerlink" title="方法函数命名原则"></a>方法函数命名原则</h2><ul>
<li>方法函数名以小写字母开头，方法函数名由多个单词组成时，除第一个单词首字母小写，其他单词首字母大写然后连接</li>
<li>方法函数名中禁止出现拼音和英文单词的组合，更不允许出现汉字，不推荐拼音来命名</li>
<li>方法函数名要浅显易懂，达到望文生义的效果</li>
</ul>
<h2 id="代码命名约定"><a href="#代码命名约定" class="headerlink" title="代码命名约定"></a>代码命名约定</h2><p><strong>1.server层</strong></p>
<ul>
<li>获取多个数据方法使用（带搜素） getList</li>
<li>获取通过 id 获取详情 getInfoById</li>
<li>插入方法使用 insert</li>
<li>更新方法使用 update </li>
<li>删除方法使用 drop</li>
<li>统计方法使用 count</li>
<li>判断方法使用 is</li>
<li>检查 check</li>
<li>更新固定几个字段使用 change</li>
<li></li>
</ul>
<p><strong>2.控制层</strong></p>
<ul>
<li>更新方法使用 edit </li>
<li>删除方法使用 del</li>
<li>插入方法使用 add</li>
<li>获取单个数据方法使用 get </li>
<li>获取多个数据方法使用 getList</li>
<li>获取查找数据方法使用 getSearchList</li>
<li>判断方法使用 is</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://745162202.github.io/2019/09/14/增加代码可读性的命名规范/" data-id="ck59t0zsc0007g0mety3257qv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/11/thinkphp多次load引出foreach的奇怪现象/">thinkphp 多次 load 引出 foreach 的奇怪现象</a>
          </li>
        
          <li>
            <a href="/2019/12/15/mvc的隔离性和一致性/">mvc的隔离性和一致性</a>
          </li>
        
          <li>
            <a href="/2019/12/06/框架的事务嵌套/">框架的事务嵌套</a>
          </li>
        
          <li>
            <a href="/2019/12/04/InnoDB索引/">InnoDB索引</a>
          </li>
        
          <li>
            <a href="/2019/11/23/InnoDB页/">InnoDB页</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>